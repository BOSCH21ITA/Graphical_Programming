/******************************************************************************
 * DISCLAIMER
 * This code has been generated by ASCET-DEVELOPER Community Edition.
 * It shall be used only in projects for non commercial use.
 * See license terms and conditions under https://www.etas.com/en/products/download_center.php.
 ******************************************************************************/

/********************************************************************************
 * DO NOT EDIT!
 * AUTOMATICALLY GENERATED
 * DESCRIPTION:
 *   Virtual PC operating system implementation
 ********************************************************************************/
#include "etasVpOs.h"

#ifdef XCP_SLAVE
	#include "a_targma.h"

	extern void xcpSlaveInterfaceStart(ASDObjectPtr topObject);

	/* for XCP extensions */
	#define INTECRIO_CLOCK		3
	#define INTECRIO_ADMIN		4
	
	bool clockIsRunning ()
	{
	    vrtaEvent   vrtaEvent;
	
	    vrtaEvent.devID = INTECRIO_CLOCK;
	    vrtaEvent.devEvent = INTECRIO_VIRTUAL_CLOCK_DEVICE_EVENT_ID_State;
	    vrtaEvent.devEventLen = 0;
	    vrtaEvent.devEventData = NULL;
	
	    return ( RTVECUErr_NONE == vrtaGetState( INTECRIO_CLOCK, &vrtaEvent ) ) && ( 1 == vrtaEvent.devEmbeddedData.uVal );
	}
	
	typedef enum INTECRIO_CLOCK_TYPE CLOCK_TYPE;
	
	void setClockType (CLOCK_TYPE clockType)
	{
	    vrtaAction action;
	
	    action.devID = INTECRIO_CLOCK;
	    action.devAction = INTECRIO_VIRTUAL_CLOCK_DEVICE_ACTION_ID_Clock;
	    action.devActionLen = sizeof (unsigned int);
	    action.devActionData = 0;
	    action.devEmbeddedData.uVal = clockType;
	
	    vrtaSendAction (INTECRIO_CLOCK, &action);
	}
	
	void startOsClock (unsigned int remainingExecutionSteps)
	{
	    vrtaAction action;
	
	    action.devID = INTECRIO_CLOCK;
	    action.devAction = INTECRIO_VIRTUAL_CLOCK_DEVICE_ACTION_ID_Start;
	    action.devActionLen = sizeof (unsigned int);
	    action.devActionData = 0;
	    action.devEmbeddedData.uVal = remainingExecutionSteps;
	
	    vrtaSendAction (INTECRIO_CLOCK, &action);
	}
	
	void stopOsClock ()
	{
	    vrtaAction action;
	
	    action.devID = INTECRIO_CLOCK;
	    action.devAction = INTECRIO_VIRTUAL_CLOCK_DEVICE_ACTION_ID_Stop;
	    action.devActionLen = 0;
	    action.devActionData = 0;
	
	    vrtaSendAction (INTECRIO_CLOCK, &action);
	}
	
	void startRealTimeClockAndOS ()
	{
	    if (!clockIsRunning())
	    {
	        setClockType(INTECRIO_CLOCK_TYPE_REAL_TIME);
	        startOsClock(0);
	
	        setNextAppMode(UserAppMode);
	    }
	}

	uint8 checkCommandlineOption (char* option)
	{
	    vrtaEvent   commandlineEvent;
	
	    commandlineEvent.devID = AM_DEVICE_ID;
	    commandlineEvent.devEvent = AM_EVENT_ID_Option;
	    commandlineEvent.devEventLen = strlen( option );
	    commandlineEvent.devEventData = NULL;
	
	    strcpy( (char*)( commandlineEvent.devEmbeddedData.bVal ), option ); // This is OK if the string is < 16 characters long.
	
	    return ( RTVECUErr_NONE == vrtaGetState( AM_DEVICE_ID, &commandlineEvent ) ) && ( 1 == commandlineEvent.devEmbeddedData.uVal );
	}
#endif

uint32 etasGetCounterPeriodUs (void)
{
	return 10000;
}


T_appModeTableEntry appModeEntries[] =
{
	{(AppModeType *)&etasStartupAppMode, "init"},
	{(AppModeType *)&etasInactiveAppMode, "inactive"},
	{(AppModeType *)&UserAppModeAppMode, "active"}
};

T_appModeTable appModeTable = 
{
	1+2,	/* number of modes in appModeEntries */
	0+2,	/* index of default application mode */
	&appModeEntries[0]
};

DECLARE_TASK_MONITOR(etasConfigTask);
DECLARE_TASK_MONITOR(Task0);

T_taskTableEntry taskTableEntries[] = {
	{(TaskType *)&etasConfigTask, "etasConfigTask", TASK_MONITOR_PTR(etasConfigTask)},
	{(TaskType *)&Task0, "Task0", TASK_MONITOR_PTR(Task0)},
};

T_taskTable taskTable = {
	/* number of tasks (user defined tasks + internally defined tasks) */
	2,
	/* pointers to tasks */
	&taskTableEntries[0]
};

void etasStartupInitTask (void)
{
	#ifdef STARTUP_INIT_TASK_START_FW_HOOK
	    STARTUP_INIT_TASK_START_FW_HOOK
	#endif

	etasInitModelProcess();
	etasInitOsProcess();

#ifdef XCP_SLAVE
	xcpSlaveInterfaceStart(simMan_c.targetTop);
	if (checkCommandlineOption("startOS")) {
		startRealTimeClockAndOS();
	}
#endif

}

void etasInactiveInitTask (void)
{
#ifdef INACTIVE_INIT_TASK_START_FW_HOOK
	INACTIVE_INIT_TASK_START_FW_HOOK
#endif

#ifdef INACTIVE_INIT_TASK_END_FW_HOOK
	INACTIVE_INIT_TASK_END_FW_HOOK
#endif
}

extern void StartupTask();

void UserAppModeInitTask(void)
{
#ifdef USER_APP_MODE_INIT_TASK_START_FW_HOOK
	USER_APP_MODE_INIT_TASK_START_FW_HOOK
#endif

	StartupTask();

#ifdef USER_APP_MODE_INIT_TASK_END_FW_HOOK
	USER_APP_MODE_INIT_TASK_END_FW_HOOK
#endif
}

void etasInitTasks(void)
{
	AppModeType curAppMode = GetActiveApplicationMode();
	switch(curAppMode)
	{
		case etasStartup:
			etasStartupInitTask();
			break;
		case etasInactive:
			etasInactiveInitTask();
			break;
		case UserAppMode:
			UserAppModeInitTask();
			break;
	}
}

/******************************** Exit tasks **********************************/
void etasStartupExitTask(void)
{
#ifdef STARTUP_EXIT_TASK_START_FW_HOOK
	STARTUP_EXIT_TASK_START_FW_HOOK
#endif

#ifdef STARTUP_EXIT_TASK_END_FW_HOOK
	STARTUP_EXIT_TASK_END_FW_HOOK
#endif
}

void etasInactiveExitTask(void)
{
#ifdef INACTIVE_EXIT_TASK_START_FW_HOOK
	INACTIVE_EXIT_TASK_START_FW_HOOK
#endif

#ifdef INACTIVE_EXIT_TASK_END_FW_HOOK
	INACTIVE_EXIT_TASK_END_FW_HOOK
#endif
}

extern void ShutdownTask();

void UserAppModeExitTask(void)
{
	ShutdownTask();
}

void etasExitTasks(void)
{
	AppModeType curAppMode = GetActiveApplicationMode();
	switch(curAppMode)
	{
		case etasStartup:
			etasStartupExitTask();
			break;
		case etasInactive:
			etasInactiveExitTask();
			break;
		case UserAppMode:
			UserAppModeExitTask();
			break;
	}
}

/**** OS administration ****/
T_osAdmin osAdmin = {
	&appModeTable,
	&taskTable
};

/* stimuligenerator table  */
sgTaskTableEntry sgTaskTable[2] = {NULL};

/* crossbar hooks */
crossbarHookTableEntry crossbarHookTableTask0[1] = {NULL}; /* crossbar hook in task Task0 */
crossbarHookTableEntry crossbarHookTableEtasInitTask[1] = {NULL}; /* crossbar hook in task EtasInitTask */
crossbarTaskTableEntry crossbarTaskTable[4] = {   /* crossbar task table */
	{NULL},
	{&crossbarHookTableTask0[0]},
	{&crossbarHookTableEtasInitTask[0]},
	{NULL}
};

/**** INTECRIO Virtual Prototyping RTA-TRACE hook ****/
void rtaTraceHook()
{
}

extern void clockDevice_IncrementMatch(TickType match);

void Tick_etasCounter(void)
{
	ScheduleStatusType stat_etasCounter;

	osAdvanceCounter_etasCounter(&stat_etasCounter);
	if (stat_etasCounter.status & OS_STATUS_RUNNING) {
		clockDevice_IncrementMatch(stat_etasCounter.expiry);
	}
}
